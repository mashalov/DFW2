#include "stdafx.h"
#include "Messages.h"


using namespace DFW2;

CDFW2Messages::CDFW2Messages()
{
	m_VarNameMap[VARUNIT_KVOLTS]	= _T("кВ");
	m_VarNameMap[VARUNIT_VOLTS]		= _T("В");
	m_VarNameMap[VARUNIT_KAMPERES]	= _T("кА");
	m_VarNameMap[VARUNIT_AMPERES]	= _T("А");
	m_VarNameMap[VARUNIT_DEGREES]	= _T("°");
	m_VarNameMap[VARUNIT_RADIANS]	= _T("рад");
	m_VarNameMap[VARUNIT_PU]		= _T("о.е.");
	m_VarNameMap[VARUNIT_MW]		= _T("МВт");
	m_VarNameMap[VARUNIT_MVAR]		= _T("МВар");
	m_VarNameMap[VARUNIT_MVA]		= _T("МВА");
	m_VarNameMap[VARUNIT_SIEMENS]	= _T("См");
	m_VarNameMap[VARUNIT_PIECES]	= _T("Шт");
	m_VarNameMap[VARUNIT_SECONDS]   = _T("с");
	m_VarNameMap[VARUNIT_OHM]		= _T("Ом");
}

const _TCHAR* CDFW2Messages::m_cszBranchNodeNotFound = _T("Узел {} не найден для ветви {}-{} ({})");
const _TCHAR* CDFW2Messages::m_cszDuplicateDevice    = _T("Объект {} имеет неуникальный идентификатор");
const _TCHAR* CDFW2Messages::m_cszBranchLooped = _T("Ветвь начинается и заканчивается в узле {}");
const _TCHAR* CDFW2Messages::m_cszKLUOk = _T("KLU - OK");
const _TCHAR* CDFW2Messages::m_cszKLUSingular = _T("KLU - Сингулярная матрица");
const _TCHAR* CDFW2Messages::m_cszKLUOutOfMemory = _T("KLU - Недостаточно памяти");
const _TCHAR* CDFW2Messages::m_cszKLUInvalidInput = _T("KLU - Неправильные данные");
const _TCHAR* CDFW2Messages::m_cszKLUIntOverflow = _T("KLU - Переполнение целого числа");
const _TCHAR* CDFW2Messages::m_cszKLUUnknownError = _T("KLU - Неизвестная ошибка с кодом {}");
const _TCHAR* CDFW2Messages::m_cszInitLoopedInfinitely = _T("При инициализации устройств обнаружен бесконечный цикл");
const _TCHAR* CDFW2Messages::m_cszDeviceContainerFailedToInit = _T("Отказ инициализации для устройств типа {} код {}");
const _TCHAR* CDFW2Messages::m_cszStepAndOrderChanged = _T("t={:15.012f} {:>3} Порядок и шаг метода изменен : порядок {} шаг {} с");
const _TCHAR* CDFW2Messages::m_cszStepChanged = _T("t={:15.012f} {:>3} Шаг метода изменен : шаг {} с ({}), порядок {}");
const _TCHAR* CDFW2Messages::m_cszStepAndOrderChangedOnNewton = _T("t={:15.012f} {:>3} Порядок и шаг метода изменен по Ньютону: порядок {} шаг {} с");
const _TCHAR* CDFW2Messages::m_cszZeroCrossingStep = _T("t={:15.012f} {:>3} Шаг метода изменен для поиска ограничения: шаг {} с в устройстве {}");
const _TCHAR* CDFW2Messages::m_cszStepChangedOnError = _T("t={:15.012f} {:>3} Шаг метода изменен по корректору: шаг {} с, ошибка {} в {} от {} \"{}\" Nordsiek[{};{}]");
const _TCHAR* CDFW2Messages::m_cszStepAdjustedToDiscontinuity = _T("t={:15.012f} {:>3} Шаг метода изменен для обработки события: шаг {}");
const _TCHAR* CDFW2Messages::m_cszSynchroZoneCountChanged = _T("Обновлено количество синхронных зон : {}");
const _TCHAR* CDFW2Messages::m_cszAllNodesOff = _T("Все узлы отключены");
const _TCHAR* CDFW2Messages::m_cszNodeTripDueToZone = _T("Узел {} отключен, так как находится в зоне без источников напряжения");
const _TCHAR* CDFW2Messages::m_cszNodeRiseDueToZone = _T("Узел {} включен под напряжение, так как находится в зоне с его источником");
const _TCHAR* CDFW2Messages::m_cszUnknown = _T("Неизвестно");
const _TCHAR* CDFW2Messages::m_cszLRCDiscontinuityAt = _T("Обнаружен разрыв СХН {} при напряжении {} [о.е]. Значения  {} и {}");
const _TCHAR* CDFW2Messages::m_cszAmbigousLRCSegment = _T("В СХН {} обнаружено более одного сегмента для напряжения {}. Будет использоваться первый сегмент {}+{}V+{}VV");
const _TCHAR* CDFW2Messages::m_cszLRCStartsNotFrom0 = _T("СХН {} начинается не с нулевого напряжения {}. Начальный сегмент будет \"продолжен\" до нуля");
const _TCHAR* CDFW2Messages::m_cszLRC1And2Reserved = _T("СХН {}, заданная пользователем игнорирована. Номера СХН 1 и 2 зарезервированы под стандартные характеристики");
const _TCHAR* CDFW2Messages::m_cszWrongPrimitiveLimits = _T("Недопустимые ограничения в блоке {} в устройстве {} : {} > {}");
const _TCHAR* CDFW2Messages::m_cszWrongDeadBandParameter = _T("Недопустимое значение параметра в блоке {} в устройстве {} : {}");
const _TCHAR* CDFW2Messages::m_cszTightPrimitiveLimits = _T("Ограничения блока {} в устройстве {} должны иметь разность не менее {} : {} и {}");
const _TCHAR* CDFW2Messages::m_cszWrongPrimitiveTimeConstant = _T("Недопустимое значение постоянной времени блока {} в устройстве {} : {} с");
const _TCHAR* CDFW2Messages::m_cszWrongPrimitiveInitialConditions = _T("Начальные условия блока {} в устройстве {} не соответствуют ограничениям: {} не находится в интервале [{};{}]");
const _TCHAR* CDFW2Messages::m_cszProcessDiscontinuityLoopedInfinitely = _T("При обработке разрыва устройств обнаружен бесконечный цикл");
const _TCHAR* CDFW2Messages::m_cszDLLLoadFailed = _T("Ошибка загрузки DLL пользовательского устройства {}");
const _TCHAR* CDFW2Messages::m_cszDLLFuncMissing = _T("В DLL пользовательского устройства {} недоступны необходмые для работы функции");
const _TCHAR* CDFW2Messages::m_cszDLLBadBlocks = _T("В DLL пользовательского устройства {} обнаружено неправильное описание блоков");
const _TCHAR* CDFW2Messages::m_cszPrimitiveExternalOutput = _T("В DLL пользовательского устройства {} в блоке {} неверно задан выход");
const _TCHAR* CDFW2Messages::m_cszWrongPrimitiveinDLL = _T("В DLL пользовательского устройства {} обнаружен неизвестный тип блока с номером {}");
const _TCHAR* CDFW2Messages::m_cszTableNotFoundForCustomDevice = _T("При загрузке данных пользовательского устройства \"{}\" обнаружена ошибка \"{}\"");
const _TCHAR* CDFW2Messages::m_cszExtVarNotFoundInDevice = _T("Требуемая для устройства \"{}\" выходная переменная \"{}\" не найдена в устройстве \"{}\"");
const _TCHAR* CDFW2Messages::m_cszExtVarNoDeviceFor = _T("Нет устройства с выходной переменной \"{}\" для устройства \"{}\"");
const _TCHAR* CDFW2Messages::m_cszConstVarNotFoundInDevice = _T("Требуемая для устройства \"{}\" константа \"{}\" не найдена в устройстве \"{}\"");
const _TCHAR* CDFW2Messages::m_cszConstVarNoDeviceFor = _T("Нет устройства с константой \"{}\" для устройства \"{}\"");
const _TCHAR* CDFW2Messages::m_cszVarSearchStackDepthNotEnough = _T("Недостаточна глубина стека для поиска переменных устройств ({})");
const _TCHAR* CDFW2Messages::m_cszWrongSingleLinkIndex = _T("Попытка использовать связь №={} для устройства {}. Доступно {} связей");
const _TCHAR* CDFW2Messages::m_cszDeviceAlreadyLinked = _T("Устройство {} не может быть связано с устройством {}, так как уже связано с устройством {}");
const _TCHAR* CDFW2Messages::m_cszDeviceForDeviceNotFound = _T("Устройство Id={} не найдено для устройства {}");
const _TCHAR* CDFW2Messages::m_cszIncompatibleLinkModes = _T("Несовместимые режимы связи для устройств");
const _TCHAR* CDFW2Messages::m_cszFilePostion = _T(". Позиция файла {}");
const _TCHAR* CDFW2Messages::m_cszFileReadError = _T("Ошибка чтения файла.");
const _TCHAR* CDFW2Messages::m_cszFileWriteError = _T("Ошибка записи файла.");
const _TCHAR* CDFW2Messages::m_cszResultFileHasNewerVersion = _T("Файл результатов имеет более новую версию ({}) по сравнению с версией загрузчика результатов ({}). ");
const _TCHAR* CDFW2Messages::m_cszNoMemory = _T("Недостаточно памяти. ");
const _TCHAR* CDFW2Messages::m_cszWrongResultFile = _T("Неверный формат файла результатов. ");
const _TCHAR* CDFW2Messages::m_cszResultFileNotLoadedProperly = _T("Файл результатов не загружен. ");
const _TCHAR* CDFW2Messages::m_cszResultRoot = _T("Модель");
const _TCHAR* CDFW2Messages::m_cszWrongSymbolicLink = _T("Неверный формат символической ссылки: {}");
const _TCHAR* CDFW2Messages::m_cszObjectNotFoundByAlias = _T("Не найден объект типа {} по символической ссылке {}");
const _TCHAR* CDFW2Messages::m_cszWrongKeyForSymbolicLink = _T("Неверный формат ключа {} в символической ссылке {}");
const _TCHAR* CDFW2Messages::m_cszObjectNotFoundBySymbolicLink = _T("Объект не найден по символической ссылке {}");
const _TCHAR* CDFW2Messages::m_cszObjectHasNoPropBySymbolicLink = _T("Объект не имеет свойства {}, указанного в символической ссылке {}");
const _TCHAR* CDFW2Messages::m_cszNoCompilerDLL = _T("Компилятор пользовательских моделей недоступен");
const _TCHAR* CDFW2Messages::m_cszActionNotFoundInDLL = _T("Действие {} не найдено в скомпилированной dll");
const _TCHAR* CDFW2Messages::m_cszLogicNotFoundInDLL = _T("Логика {} не найдена в скомпилированной dll");
const _TCHAR* CDFW2Messages::m_cszWrongActionInLogicList = _T("Неверный формат ссылки на действие \"{}\" в списке действий \"{}\" элемента логики L{}");
const _TCHAR* CDFW2Messages::m_cszDuplicateActionGroupInLogic = _T("Группа действий A{} задана в списке действий \"{}\" элемента логики L{} более одного раза");
const _TCHAR* CDFW2Messages::m_cszNoActionGroupFoundInLogic = _T("Группа действий A{}, указанная в списке \"{}\" элемента логики L{} не определена в действиях");
const _TCHAR* CDFW2Messages::m_cszDuplicatedVariableUnit = _T("Единицы измерения с типом {} уже определены");
const _TCHAR* CDFW2Messages::m_cszDuplicatedDeviceType = _T("Тип устройства {} уже определен");
const _TCHAR* CDFW2Messages::m_cszTooMuchDevicesInResult = _T("Попытка добавить {} устройств из {} возможных");
const _TCHAR* CDFW2Messages::m_cszWrongParameter = _T("Неверный параметр");
const _TCHAR* CDFW2Messages::m_cszDuplicatedVariableName = _T("Неуникальное имя переменной {} для устройства типа {}");
const _TCHAR* CDFW2Messages::m_cszUnknownError = _T("Неизвестная ошибка");
const _TCHAR* CDFW2Messages::m_cszMemoryAllocError = _T("Ошибка распределения памяти {}");
const _TCHAR* CDFW2Messages::m_cszLULFConverged = _T("Линейный метод сошелся с погрешностью {} за {} итераций");
const _TCHAR* CDFW2Messages::m_cszLFRunningNewton = _T("Расчет УР методом Ньютона");
const _TCHAR* CDFW2Messages::m_cszLFRunningSeidell = _T("Расчет УР методом Зейделя");
const _TCHAR* CDFW2Messages::m_cszLFNoConvergence = _T("Не удалось сбалансировать установившийся режим");
const _TCHAR* CDFW2Messages::m_cszLFNodeVTooHigh = _T("Недопустимое напряжение в узле {} - {} номинального");
const _TCHAR* CDFW2Messages::m_cszLFNodeVTooLow = CDFW2Messages::m_cszLFNodeVTooHigh;
const _TCHAR* CDFW2Messages::m_cszLFBranchAngleExceeds90 = _T("Угол по связи {} - {} превысил 90 град - {}");
const _TCHAR* CDFW2Messages::m_cszWrongGeneratorsNumberFixed = _T("Количество генераторов для {} задано неверно {}, установлено значение 1");
const _TCHAR* CDFW2Messages::m_cszFailureAtMinimalStep = _T("Необходимая точность решения не может быть достигнута на минимальном шаге t={} {:>3} порядок {} шаг={}");
const _TCHAR* CDFW2Messages::m_cszMustBeConstPowerLRC = _T("Не найдена типовая СХН на постоянную мощность с номером -1");
const _TCHAR* CDFW2Messages::m_cszMustBeDefaultDynamicLRC = _T("Не найдена типовая СХН нагрузки в динамике с номером 0");
const _TCHAR* CDFW2Messages::m_cszResultFileWrongCompressedBlockType = _T("Неверный тип сжатого блока данных в файле результатов");
const _TCHAR* CDFW2Messages::m_cszResultFilePointsCountMismatch = _T("Размерность канала {} {} не совпадает с количеством точек в файле {}");
const _TCHAR* CDFW2Messages::m_cszDeivceDoesNotHaveAccessToModel = _T("Устройство не имеет доступа к модели");
const _TCHAR* CDFW2Messages::m_cszAdamsDamping = _T("Демпфирование Адамса-2 {}");
const _TCHAR* CDFW2Messages::m_cszOn = _T("вкл");
const _TCHAR* CDFW2Messages::m_cszOff = _T("выкл");
const _TCHAR* CDFW2Messages::m_cszIslandOfSuperNode = _T("Суперузел-представитель острова {}");
const _TCHAR* CDFW2Messages::m_cszSwitchedOffNode = _T("Отключен {} так как все ветви отключены");
const _TCHAR* CDFW2Messages::m_cszSwitchedOffBranch = _T("{} {} отключена {} так как узел {} отключен");
const _TCHAR* CDFW2Messages::m_cszSwitchedOffBranchHead		= _T("в начале");
const _TCHAR* CDFW2Messages::m_cszSwitchedOffBranchTail		= _T("в конце");
const _TCHAR* CDFW2Messages::m_cszSwitchedOffBranchComplete = _T("полностью");
const _TCHAR* CDFW2Messages::m_cszIslandCount = _T("Найдено синхронных зон {}");
const _TCHAR* CDFW2Messages::m_cszIslandSlackBusesCount = _T("Синхронная зона содержит {} включенных узлов, из них базисных узлов {}");
const _TCHAR* CDFW2Messages::m_cszIslandNoSlackBusesShutDown = _T("В синхронной зоне нет базисных узлов. Синхронная зона будет полностью отключена");
const _TCHAR* CDFW2Messages::m_cszNodeShutDownAsNotLinkedToSlack = _T("Узел {} отключен так как находится в зоне, не содержащей базисного узла");
const _TCHAR* CDFW2Messages::m_cszNoNodesForLF = _T("Для расчета УР нет включенных узлов");
const _TCHAR* CDFW2Messages::m_cszUnacceptableLF = _T("Получен недопустимый режим");
const _TCHAR* CDFW2Messages::m_cszExtVarFromOffDevice = _T("Требуемая для устройства \"{}\" выходная переменная \"{}\" найдена в отключенном устройстве \"{}\"");
const _TCHAR* CDFW2Messages::m_cszTurningOffDeviceByMasterDevice = _T("Устройство \"{}\" отключено, так как отключено связанное ведущее устройство \"{}\"");
const _TCHAR* CDFW2Messages::m_cszTurningOffDeviceDueToNoMasterDevice = _T("Устройство \"{}\" отключено, так как не найдено связанное ведущее устройство");
const _TCHAR* CDFW2Messages::m_cszMatrixSize = _T("Размерность матрицы {}, количество ненулевых элементов {}");
const _TCHAR* CDFW2Messages::m_cszTurnOnDeviceImpossibleDueToMaster = _T("Невозможно включить устройство \"{}\", так как отключено по крайней мере одно ведущее устройство \"{}\"");
const _TCHAR* CDFW2Messages::m_cszAutomaticOrScenarioFailedToInitialize = _T("При инициализации автоматики или сценария обнаружены ошибки");
const _TCHAR* CDFW2Messages::m_cszLFWrongQrangeForNode = _T("Для узла \"{}\" невозможно распределение реактивной мощности {} по генераторам c суммарным диапазоном [{};{}]");
const _TCHAR* CDFW2Messages::m_cszLFWrongQrangeForSuperNode = _T("Для суперузла \"{}\" невозможно распределение реактивной мощности {} по узлам c суммарным диапазоном [{};{}]");
const _TCHAR* CDFW2Messages::m_cszLFError = _T("Ошибка при расчете УР");
const _TCHAR* CDFW2Messages::m_cszCannotChangePermanentDeviceState = _T("Невозможно изменить состояние устройства \"{}\"");
const _TCHAR* CDFW2Messages::m_cszWrongUnom = _T("Недопустимое значение номинального напряжения \"{}\" Uном = {}");
const _TCHAR* CDFW2Messages::m_cszWrongSourceData = _T("Обнаружена неустранимая ошибка в исходных данных");
